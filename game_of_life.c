#include <stdio.h> // Подключение библиотеки для ввода-вывода.
#include <stdlib.h> // Подключение библиотеки для работы с памятью и генерацией случайных чисел.
#include <time.h> // Подключение библиотеки для работы с временем, чтобы использовать текущее время для инициализации генератора случайных чисел.

void initializeGridData(int grid[25][80], int size[2]); // Объявление функции для инициализации сетки случайными значениями.
void printGrid(int grid[25][80], int size[2]); // Объявление функции для вывода сетки на экран.
void calcAlive(int grid[25][80], int size[2], int nextGrid[25][80]); // Объявление функции для расчета следующего состояния сетки.
void copyGrid(int dest[25][80], int src[25][80], int size[2]); // Объявление функции для копирования содержимого одной сетки в другую.
// Разделяем объявления функций с различными типами возвращаемых данных для лучшего понимания того, что происходит и удобства рефакторинга/читаемости.
int countAliveNeighbors(int grid[25][80], int size[2], int x, int y); // Объявление функции для подсчета живых соседей клетки.

int main(void) {
    int grid[25][80]; // Инициализация массива сетки поля.
    int nextGrid[25][80]; // Инициализация массива сетки следующего шага эволюции игрового поля.
    int size[2] = {25, 80}; // Инициализация массива с данными о размере массива сетки.

    // char name[10]; // Массив символов для хранения строки модуля тестирования и отладки.

    srand(time(NULL)); // Инициализация генератора случайных чисел с использованием текущего времени для рандомизации.
    initializeGridData(grid, size); // Инициализация изначальной сетки игрового поля случайными значениями: 0 - мертва, 1 - жива.
    printGrid(grid, size); // Выводим сетку игрового поля в терминал. Это первый вывод, который отображает стартовое состояние игрового поля.

    while (1) { // Бесконечный цикл для продолжения игрового процесса.
        // scanf("%9s", name); // Считывание строки для создания иллюзии пошагового режима игры. Используется для модуля тестирования и отладки.
        calcAlive(grid, size, nextGrid); // Расчет следующего состояния сетки: определяем, какие клетки останутся живыми, какие умрут, и какие оживут.
        copyGrid(grid, nextGrid, size); // Копирование содержимого nextGrid в grid для следующей итерации.
        printGrid(grid, size); // Выводим обновленную сетку игрового поля в терминал.
    }

    return 0; // Возвращение 0, чтобы указать, что программа завершилась успешно.
}

void initializeGridData(int grid[25][80], int size[2]) {
    for (int i = 0; i < size[0]; i++) { // Проходим по каждой строке сетки.
        for (int j = 0; j < size[1]; j++) { // Проходим по каждому столбцу в текущей строке.
            grid[i][j] = rand() % 2; // Инициализация каждого элемента сетки случайным значением 0 или 1.
        }
    }
}

void printGrid(int grid[25][80], int size[2]) {
    for (int i = 0; i < size[0]; i++) { // Проходим по каждой строке сетки.
        for (int j = 0; j < size[1]; j++) { // Проходим по каждому столбцу в текущей строке.
            printf("%c", (grid[i][j]) ? 178 : 32); // Если значение клетки 1, выводим символ красивого куба(178), иначе выводим пробел(32).
        }
        printf("\n"); // Переход на новую строку после вывода всех столбцов текущей строки.
    }
}

int countAliveNeighbors(int grid[25][80], int size[2], int x, int y) {
    int aliveCubs = 0; // Переменная для подсчета живых соседей.
    for (int i = -1; i <= 1; i++) { // Проходим по строкам соседей (сверху, на уровне и снизу от текущей клетки).
        for (int j = -1; j <= 1; j++) { // Проходим по столбцам соседей (слева, на уровне и справа от текущей клетки).
            if (i == 0 && j == 0) continue; // Пропуск самой клетки, так как она не должна считаться своим соседом.
            int newX = (x + i + size[0]) % size[0]; // Обработка границ для замкнутого поля по оси X (циклический переход).
            int newY = (y + j + size[1]) % size[1]; // Обработка границ для замкнутого поля по оси Y (циклический переход).
            aliveCubs += grid[newX][newY]; // Увеличение счётчика живых клеток, если соседняя клетка жива.
        }
    }
    return aliveCubs; // Возвращение количества живых соседей.
}

void calcAlive(int grid[25][80], int size[2], int nextGrid[25][80]) {
    for (int i = 0; i < size[0]; i++) { // Проходим по каждой строке сетки.
        for (int j = 0; j < size[1]; j++) { // Проходим по каждому столбцу в текущей строке.
            int aliveCubs = countAliveNeighbors(grid, size, i, j); // Подсчет количества живых соседей для текущей клетки.
            // Применение правил игры на основе расчёта выживаемости или размножения клетки.
            if (grid[i][j]) { // Клетка живая.
                if (aliveCubs < 2 || aliveCubs > 3) {
                    nextGrid[i][j] = 0; // Клетка умирает от одиночества или перенаселения.
                } else {
                    nextGrid[i][j] = 1; // Клетка остается живой при 2 или 3 живых соседях.
                }
            } else { // Клетка мертвая.
                if (aliveCubs == 3) {
                    nextGrid[i][j] = 1; // Клетка становится живой при ровно 3 живых соседях.
                } else {
                    nextGrid[i][j] = 0; // Клетка остается мертвой.
                }
            }
        }
    }
}

void copyGrid(int dest[25][80], int src[25][80], int size[2]) {
    for (int i = 0; i < size[0]; i++) { // Проходим по каждой строке сетки.
        for (int j = 0; j < size[1]; j++) { // Проходим по каждому столбцу в текущей строке.
            dest[i][j] = src[i][j]; // Копирование значений из массива src в массив dest.
        }
    }
}
